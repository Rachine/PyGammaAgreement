========
How-to's
========

This section will explain how to make the most of ``pygamma-agreement``'s customization possibilities.

Setting up your own positional dissimilarity
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The only positionnal dissimilarity available in ``pygamma-agreement`` is the *Positional Sporadic dissimilarity*,
introduced by [mathet2015]_. In this part, we'll detail how to use your own for computing the gamma agreement.

A ``Dissimilarity`` class is a class that holds the information needed to **compile** a dissimilarity function.
It is made this way to optimize as much as possible the very costly computation of gamma. Let's start by
**inheriting** the ``AbstractDissimilarity`` class :

.. code-block:: python

    from pygamma_agreement import AbstractDissimilarity, Unit
    import numpy as np
    from typing import Callable

    class MyPositionalDissimilarity(AbstractDissimilarity):
        def __init__(self, delta_empty=1.0):
            super().__init__(delta_empty=delta_empty)

        # Abstract methods overrides
        def compile_d_mat(self) -> Callable[[np.ndarray, np.ndarray], np.float32]:
            ...

        def d(self, unit1: Unit, unit2: Unit) -> float:
            ...


This is essentially the minimum skeleton needed to define a new positional dissimilarity. You can also use additionnal
attributes to make your dissimilarity more parametrizable.

For this example, the dissimilarity we'll be implementing will be defined as such : for :math:`p` an integer,

.. math::

    d_p(u, v) = (|start(u) - start(v)|^p + |end(u) - end(v)|^p)^{\frac{1}{p}} \times \Delta_{\emptyset}

.. math::

    d_p(u_{\emptyset}, u) = d_p(u, u_{\emptyset}) = \Delta_{\emptyset}

thus, let's redefine the constructor accordingly :

.. code-block:: python

    def __init__(self, p: int, delta_empty=1.0):
            self.p = p
            assert p > 0
            super().__init__(delta_empty=delta_empty)

Great. Now, let's explain what the ``d`` method is.

The ``AbstractDissimilarity.d`` method is essentially the python method that returns the dissimilarity between the two
non-empty given units. When the units are empty, any algorithm from ``pygamma-agreement`` that uses a dissimilarity
object will do the checking out of this method and use the ``delta_empty`` attribute accordingly.

So, you only have to implement the first part of :math:`d_p`'s definition.

.. code-block:: python

    def d(self, unit1: Unit, unit2: Unit) -> float:
        return ( abs(unit1.segment.start - unit2.segment.start)**self.p
                 + abs(unit1.segment.end - unit2.segment.end)**self.p ) ** (1/self.p)

This method is essentially used in the gamma-cat computation, since it is too slow for the costly gamma algorithm.

It's time to explain the essential part of the dissimilarity : the ``compile_d_mat`` method.
To minimize computation time of the gamma-agreement, the dissimilarities are used in a C-compiled form
generated by the ``numba`` library. To accomplish this, they need to keep the same signature, and to
only use native python or ``numpy`` types/operations internally.

Let's write the ``MyPositionalDissimilarity.compile_d_mat`` method to better explain it :

.. code-block:: python

    def compile_d_mat(self) -> Callable[[np.ndarray, np.ndarray], np.float32]:
        # Calling self inside d_mat makes the compiler choke, so you need to copy attributes in locals.
        p = self.p
        delta_empty = self.delta_empty
        from pygamma_agreement import dissimilarity_dec

        @dissimilarity_dec  # This decorator specifies that this function will be compiled.
        def d_mat(unit1: np.ndarray, unit2: np.ndarray):
            # We're in numba environment here, which means that only python/numpy types and operations will work.
            return (abs(unit1[0] - unit2[0])**p
                    + abs(unit1[1] - unit2[1])**p)**(1 / p) * delta_empty

        return d_mat

You'll notice that the units' attributes are accessed by index. The correspondance is the following :

.. code-block:: python

    unit_array: np.ndarray
    unit_object: Unit

    unit_array[0] == unit_object.segment.start
    unit_array[1] == unit_object.segment.end
    unit_array[2] == unit_object.segment.end - unit_object.segment.start

Now, the dissimilarity is ready to be used !

.. code-block:: python

    from pygamma_agreement import Continuum
    continuum: Continuum
    dissim = MyPositionalDissimilarity(p=2, delta_empty=1.0)
    gamma_results = continuum.compute_gamma(dissim)

Setting up your own categorical dissimilarity
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For compatibility reasons, it is not possible to manipulate string types in a ``numba``-compiled environment.
Instead, category-to-category dissimilarities are pre-computed in python environment. Thus, there is a very simple
interface avaible : You just need to inherit the ``LambdaCategoricalDissimilarity``, and override the
``cat_dissim_func`` static method :

.. code-block:: python
    class LevenshteinCategoricalDissimilarity(LambdaCategoricalDissimilarity):
    # Precomputation requires the category labels to be saved. Don't use this dissimilarity with
    # a continuum containing unspecified categories
    def __init__(self, labels: Iterable[str], delta_empty: float = 1.0):
        super().__init__(labels, delta_empty)

    @staticmethod
    def cat_dissim_func(str1: str, str2: str) -> float:
        return ...  # Your categorical dissimilarity function. Results should be in [0, 1]

Beware that in reality, the resulting dissimilarity between categories ``a`` and ``b`` will be
``cat_dissim_func(a, b) * delta_empty``

..  [mathet2015] Yann Mathet et Al.
    The Unified and Holistic Method Gamma (γ) for Inter-Annotator Agreement
    Measure and Alignment (Yann Mathet, Antoine Widlöcher, Jean-Philippe Métivier)

